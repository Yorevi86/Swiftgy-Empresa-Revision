{"version":3,"sources":["skrollr.js"],"names":["window","document","undefined","documentElement","body","skrollr","get","_instance","init","options","Skrollr","VERSION","hasProp","Object","prototype","hasOwnProperty","Math","getStyle","getComputedStyle","EVENT_TOUCHSTART","EVENT_TOUCHMOVE","EVENT_TOUCHCANCEL","EVENT_TOUCHEND","rxTouchIgnoreTags","rxTrim","rxKeyframeAttribute","rxPropValue","rxPropEasing","rxCamelCase","rxCamelCaseFn","str","letter","toUpperCase","rxNumericValue","rxInterpolateString","rxRGBAIntegerColor","rxGradient","theCSSPrefix","theDashedCSSPrefix","easings","begin","end","linear","p","quadratic","cubic","swing","cos","PI","sqrt","outCubic","pow","bounce","a","abs","rxPrefixes","style","k","match","slice","-webkit-","-moz-","-ms-","-o-","toLowerCase","detectCSSPrefix","this","_constants","constants","easing","e","_edgeStrategy","edgeStrategy","_listeners","beforerender","render","keyframe","_forceHeight","forceHeight","_scale","scale","_mobileDeceleration","mobileDeceleration","_smoothScrollingEnabled","smoothScrolling","_smoothScrollingDuration","smoothScrollingDuration","_smoothScrolling","targetTop","getScrollTop","_isMobile","mobileCheck","test","navigator","userAgent","vendor","opera","_skrollrBody","getElementById","skrollrBody","_detect3DTransforms","_initMobile","_updateClass","SKROLLR_CLASS","refresh","_addEvent","width","clientWidth","height","clientHeight","_lastViewportHeight","_lastViewportWidth","_requestReflow","requestAnimFrame","requestAnimationFrame","lastTime","_now","callback","deltaTime","delay","max","setTimeout","polyfillRAF","animloop","_render","_animFrame","elements","elementIndex","elementsLength","ignoreID","_skrollables","_skrollableIdCounter","getElementsByTagName","length","el","anchorTarget","keyFrames","smoothScrollThis","emitEvents","attributes","styleAttr","classAttr","id","attributeIndex","attributesLength","attr","name","kf","props","value","element","eventType","replace","push","constant","substr","offset","isPercentage","anchor1","anchor2","mode","anchors","isEnd","querySelector","cssText","_getClass","lastFrameIndex","_reflow","sk","_parseProps","_fillProps","relativeToAbsolute","viewportAnchor","elementAnchor","viewportHeight","box","getBoundingClientRect","absolute","top","boxHeight","bottom","animateTo","now","scrollTop","duration","_scrollAnimation","startTop","topDiff","startTime","endTime","done","call","stopAnimateTo","isAnimatingTo","isMobile","setScrollTop","force","_forceRender","_mobileOffset","min","_maxKeyFrame","scrollTo","pageYOffset","getMaxScrollTop","on","fn","off","destroy","cancelAnimFrame","cancelAnimationFrame","timeout","clearTimeout","polyfillCAF","_removeAllEvents","skrollableIndex","skrollablesLength","_reset","overflow","setStyle","_direction","_lastTop","_translateZ","initialElement","initialTouchY","initialTouchX","currentElement","currentTouchY","currentTouchX","lastTouchY","deltaY","currentTouchTime","lastTouchTime","join","touch","changedTouches","target","nodeType","parentNode","clientY","clientX","timeStamp","tagName","preventDefault","type","blur","activeElement","distanceY","distanceX","focus","clickEvent","createEvent","initMouseEvent","view","screenX","screenY","ctrlKey","altKey","shiftKey","metaKey","dispatchEvent","speed","targetOffset","targetRatio","afterAnimationCallback","progress","renderTop","_lastRenderCall","listenerParams","curTop","lastTop","maxTop","direction","fakeFrame","actualFrame","key","skrollable","frame","frames","framesLength","firstFrame","lastFrame","beforeFirst","afterLast","firstOrLastFrame","edge","SKROLLABLE_CLASS","_emitEvent","_interpolateString","indexOf","setAttribute","keyFrameIndex","left","right","_calcInterpolation","_calcSteps","keyFramesLength","prop","exec","_parseProp","val","numbers","lastIndex","rgba","n","s","unshift","propList","_fillPropForFrame","val1","val2","valueIndex","val1Length","interpolated","undo","elementsIndex","concat","dirtyStyleAttr","dirtyClassAttr","computedStyle","computedTransform","getPropertyValue","computedTransformWithPrefix","isNaN","styleFloat","cssFloat","ignore","addEvent","names","intermediate","event","srcElement","returnValue","defaultPrevented","nameCounter","namesLength","split","addEventListener","attachEvent","_registeredEvents","listener","_removeEvent","removeEvent","removeEventListener","detachEvent","eventData","eventCounter","eventsLength","pos","constantValue","processedConstants","_processConstants","_getDocumentHeight","sort","_keyFrameComparator","_updateDependentKeyFrames","copy","skrollrBodyHeight","offsetHeight","scrollHeight","SVGElement","add","remove","classRemoveIndex","removeLength","_untrim","_trim","classAddIndex","addLength","Date","b","define","amd","module","exports"],"mappings":"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","file":"skrollr.js","sourcesContent":["/*!\n * skrollr core\n *\n * Alexander Prinzhorn - https://github.com/Prinzhorn/skrollr\n *\n * Free to use under terms of MIT license\n */\n(function(window, document, undefined) {\n\t'use strict';\n\n\t/*\n\t * Global api.\n\t */\n\tvar skrollr = {\n\t\tget: function() {\n\t\t\treturn _instance;\n\t\t},\n\t\t//Main entry point.\n\t\tinit: function(options) {\n\t\t\treturn _instance || new Skrollr(options);\n\t\t},\n\t\tVERSION: '0.6.30'\n\t};\n\n\t//Minify optimization.\n\tvar hasProp = Object.prototype.hasOwnProperty;\n\tvar Math = window.Math;\n\tvar getStyle = window.getComputedStyle;\n\n\t//They will be filled when skrollr gets initialized.\n\tvar documentElement;\n\tvar body;\n\n\tvar EVENT_TOUCHSTART = 'touchstart';\n\tvar EVENT_TOUCHMOVE = 'touchmove';\n\tvar EVENT_TOUCHCANCEL = 'touchcancel';\n\tvar EVENT_TOUCHEND = 'touchend';\n\n\tvar SKROLLABLE_CLASS = 'skrollable';\n\tvar SKROLLABLE_BEFORE_CLASS = SKROLLABLE_CLASS + '-before';\n\tvar SKROLLABLE_BETWEEN_CLASS = SKROLLABLE_CLASS + '-between';\n\tvar SKROLLABLE_AFTER_CLASS = SKROLLABLE_CLASS + '-after';\n\n\tvar SKROLLR_CLASS = 'skrollr';\n\tvar NO_SKROLLR_CLASS = 'no-' + SKROLLR_CLASS;\n\tvar SKROLLR_DESKTOP_CLASS = SKROLLR_CLASS + '-desktop';\n\tvar SKROLLR_MOBILE_CLASS = SKROLLR_CLASS + '-mobile';\n\n\tvar DEFAULT_EASING = 'linear';\n\tvar DEFAULT_DURATION = 1000;//ms\n\tvar DEFAULT_MOBILE_DECELERATION = 0.004;//pixel/msÂ²\n\n\tvar DEFAULT_SKROLLRBODY = 'skrollr-body';\n\n\tvar DEFAULT_SMOOTH_SCROLLING_DURATION = 200;//ms\n\n\tvar ANCHOR_START = 'start';\n\tvar ANCHOR_END = 'end';\n\tvar ANCHOR_CENTER = 'center';\n\tvar ANCHOR_BOTTOM = 'bottom';\n\n\t//The property which will be added to the DOM element to hold the ID of the skrollable.\n\tvar SKROLLABLE_ID_DOM_PROPERTY = '___skrollable_id';\n\n\tvar rxTouchIgnoreTags = /^(?:input|textarea|button|select)$/i;\n\n\tvar rxTrim = /^\\s+|\\s+$/g;\n\n\t//Find all data-attributes. data-[_constant]-[offset]-[anchor]-[anchor].\n\tvar rxKeyframeAttribute = /^data(?:-(_\\w+))?(?:-?(-?\\d*\\.?\\d+p?))?(?:-?(start|end|top|center|bottom))?(?:-?(top|center|bottom))?$/;\n\n\tvar rxPropValue = /\\s*(@?[\\w\\-\\[\\]]+)\\s*:\\s*(.+?)\\s*(?:;|$)/gi;\n\n\t//Easing function names follow the property in square brackets.\n\tvar rxPropEasing = /^(@?[a-z\\-]+)\\[(\\w+)\\]$/;\n\n\tvar rxCamelCase = /-([a-z0-9_])/g;\n\tvar rxCamelCaseFn = function(str, letter) {\n\t\treturn letter.toUpperCase();\n\t};\n\n\t//Numeric values with optional sign.\n\tvar rxNumericValue = /[\\-+]?[\\d]*\\.?[\\d]+/g;\n\n\t//Used to replace occurences of {?} with a number.\n\tvar rxInterpolateString = /\\{\\?\\}/g;\n\n\t//Finds rgb(a) colors, which don't use the percentage notation.\n\tvar rxRGBAIntegerColor = /rgba?\\(\\s*-?\\d+\\s*,\\s*-?\\d+\\s*,\\s*-?\\d+/g;\n\n\t//Finds all gradients.\n\tvar rxGradient = /[a-z\\-]+-gradient/g;\n\n\t//Vendor prefix. Will be set once skrollr gets initialized.\n\tvar theCSSPrefix = '';\n\tvar theDashedCSSPrefix = '';\n\n\t//Will be called once (when skrollr gets initialized).\n\tvar detectCSSPrefix = function() {\n\t\t//Only relevant prefixes. May be extended.\n\t\t//Could be dangerous if there will ever be a CSS property which actually starts with \"ms\". Don't hope so.\n\t\tvar rxPrefixes = /^(?:O|Moz|webkit|ms)|(?:-(?:o|moz|webkit|ms)-)/;\n\n\t\t//Detect prefix for current browser by finding the first property using a prefix.\n\t\tif(!getStyle) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar style = getStyle(body, null);\n\n\t\tfor(var k in style) {\n\t\t\t//We check the key and if the key is a number, we check the value as well, because safari's getComputedStyle returns some weird array-like thingy.\n\t\t\ttheCSSPrefix = (k.match(rxPrefixes) || (+k == k && style[k].match(rxPrefixes)));\n\n\t\t\tif(theCSSPrefix) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t//Did we even detect a prefix?\n\t\tif(!theCSSPrefix) {\n\t\t\ttheCSSPrefix = theDashedCSSPrefix = '';\n\n\t\t\treturn;\n\t\t}\n\n\t\ttheCSSPrefix = theCSSPrefix[0];\n\n\t\t//We could have detected either a dashed prefix or this camelCaseish-inconsistent stuff.\n\t\tif(theCSSPrefix.slice(0,1) === '-') {\n\t\t\ttheDashedCSSPrefix = theCSSPrefix;\n\n\t\t\t//There's no logic behind these. Need a look up.\n\t\t\ttheCSSPrefix = ({\n\t\t\t\t'-webkit-': 'webkit',\n\t\t\t\t'-moz-': 'Moz',\n\t\t\t\t'-ms-': 'ms',\n\t\t\t\t'-o-': 'O'\n\t\t\t})[theCSSPrefix];\n\t\t} else {\n\t\t\ttheDashedCSSPrefix = '-' + theCSSPrefix.toLowerCase() + '-';\n\t\t}\n\t};\n\n\tvar polyfillRAF = function() {\n\t\tvar requestAnimFrame = window.requestAnimationFrame || window[theCSSPrefix.toLowerCase() + 'RequestAnimationFrame'];\n\n\t\tvar lastTime = _now();\n\n\t\tif(_isMobile || !requestAnimFrame) {\n\t\t\trequestAnimFrame = function(callback) {\n\t\t\t\t//How long did it take to render?\n\t\t\t\tvar deltaTime = _now() - lastTime;\n\t\t\t\tvar delay = Math.max(0, 1000 / 60 - deltaTime);\n\n\t\t\t\treturn window.setTimeout(function() {\n\t\t\t\t\tlastTime = _now();\n\t\t\t\t\tcallback();\n\t\t\t\t}, delay);\n\t\t\t};\n\t\t}\n\n\t\treturn requestAnimFrame;\n\t};\n\n\tvar polyfillCAF = function() {\n\t\tvar cancelAnimFrame = window.cancelAnimationFrame || window[theCSSPrefix.toLowerCase() + 'CancelAnimationFrame'];\n\n\t\tif(_isMobile || !cancelAnimFrame) {\n\t\t\tcancelAnimFrame = function(timeout) {\n\t\t\t\treturn window.clearTimeout(timeout);\n\t\t\t};\n\t\t}\n\n\t\treturn cancelAnimFrame;\n\t};\n\n\t//Built-in easing functions.\n\tvar easings = {\n\t\tbegin: function() {\n\t\t\treturn 0;\n\t\t},\n\t\tend: function() {\n\t\t\treturn 1;\n\t\t},\n\t\tlinear: function(p) {\n\t\t\treturn p;\n\t\t},\n\t\tquadratic: function(p) {\n\t\t\treturn p * p;\n\t\t},\n\t\tcubic: function(p) {\n\t\t\treturn p * p * p;\n\t\t},\n\t\tswing: function(p) {\n\t\t\treturn (-Math.cos(p * Math.PI) / 2) + 0.5;\n\t\t},\n\t\tsqrt: function(p) {\n\t\t\treturn Math.sqrt(p);\n\t\t},\n\t\toutCubic: function(p) {\n\t\t\treturn (Math.pow((p - 1), 3) + 1);\n\t\t},\n\t\t//see https://www.desmos.com/calculator/tbr20s8vd2 for how I did this\n\t\tbounce: function(p) {\n\t\t\tvar a;\n\n\t\t\tif(p <= 0.5083) {\n\t\t\t\ta = 3;\n\t\t\t} else if(p <= 0.8489) {\n\t\t\t\ta = 9;\n\t\t\t} else if(p <= 0.96208) {\n\t\t\t\ta = 27;\n\t\t\t} else if(p <= 0.99981) {\n\t\t\t\ta = 91;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn 1 - Math.abs(3 * Math.cos(p * a * 1.028) / a);\n\t\t}\n\t};\n\n\t/**\n\t * Constructor.\n\t */\n\tfunction Skrollr(options) {\n\t\tdocumentElement = document.documentElement;\n\t\tbody = document.body;\n\n\t\tdetectCSSPrefix();\n\n\t\t_instance = this;\n\n\t\toptions = options || {};\n\n\t\t_constants = options.constants || {};\n\n\t\t//We allow defining custom easings or overwrite existing.\n\t\tif(options.easing) {\n\t\t\tfor(var e in options.easing) {\n\t\t\t\teasings[e] = options.easing[e];\n\t\t\t}\n\t\t}\n\n\t\t_edgeStrategy = options.edgeStrategy || 'set';\n\n\t\t_listeners = {\n\t\t\t//Function to be called right before rendering.\n\t\t\tbeforerender: options.beforerender,\n\n\t\t\t//Function to be called right after finishing rendering.\n\t\t\trender: options.render,\n\n\t\t\t//Function to be called whenever an element with the `data-emit-events` attribute passes a keyframe.\n\t\t\tkeyframe: options.keyframe\n\t\t};\n\n\t\t//forceHeight is true by default\n\t\t_forceHeight = options.forceHeight !== false;\n\n\t\tif(_forceHeight) {\n\t\t\t_scale = options.scale || 1;\n\t\t}\n\n\t\t_mobileDeceleration = options.mobileDeceleration || DEFAULT_MOBILE_DECELERATION;\n\n\t\t_smoothScrollingEnabled = options.smoothScrolling !== false;\n\t\t_smoothScrollingDuration = options.smoothScrollingDuration || DEFAULT_SMOOTH_SCROLLING_DURATION;\n\n\t\t//Dummy object. Will be overwritten in the _render method when smooth scrolling is calculated.\n\t\t_smoothScrolling = {\n\t\t\ttargetTop: _instance.getScrollTop()\n\t\t};\n\n\t\t//A custom check function may be passed.\n\t\t_isMobile = ((options.mobileCheck || function() {\n\t\t\treturn (/Android|iPhone|iPad|iPod|BlackBerry/i).test(navigator.userAgent || navigator.vendor || window.opera);\n\t\t})());\n\n\t\tif(_isMobile) {\n\t\t\t_skrollrBody = document.getElementById(options.skrollrBody || DEFAULT_SKROLLRBODY);\n\n\t\t\t//Detect 3d transform if there's a skrollr-body (only needed for #skrollr-body).\n\t\t\tif(_skrollrBody) {\n\t\t\t\t_detect3DTransforms();\n\t\t\t}\n\n\t\t\t_initMobile();\n\t\t\t_updateClass(documentElement, [SKROLLR_CLASS, SKROLLR_MOBILE_CLASS], [NO_SKROLLR_CLASS]);\n\t\t} else {\n\t\t\t_updateClass(documentElement, [SKROLLR_CLASS, SKROLLR_DESKTOP_CLASS], [NO_SKROLLR_CLASS]);\n\t\t}\n\n\t\t//Triggers parsing of elements and a first reflow.\n\t\t_instance.refresh();\n\n\t\t_addEvent(window, 'resize orientationchange', function() {\n\t\t\tvar width = documentElement.clientWidth;\n\t\t\tvar height = documentElement.clientHeight;\n\n\t\t\t//Only reflow if the size actually changed (#271).\n\t\t\tif(height !== _lastViewportHeight || width !== _lastViewportWidth) {\n\t\t\t\t_lastViewportHeight = height;\n\t\t\t\t_lastViewportWidth = width;\n\n\t\t\t\t_requestReflow = true;\n\t\t\t}\n\t\t});\n\n\t\tvar requestAnimFrame = polyfillRAF();\n\n\t\t//Let's go.\n\t\t(function animloop(){\n\t\t\t_render();\n\t\t\t_animFrame = requestAnimFrame(animloop);\n\t\t}());\n\n\t\treturn _instance;\n\t}\n\n\t/**\n\t * (Re)parses some or all elements.\n\t */\n\tSkrollr.prototype.refresh = function(elements) {\n\t\tvar elementIndex;\n\t\tvar elementsLength;\n\t\tvar ignoreID = false;\n\n\t\t//Completely reparse anything without argument.\n\t\tif(elements === undefined) {\n\t\t\t//Ignore that some elements may already have a skrollable ID.\n\t\t\tignoreID = true;\n\n\t\t\t_skrollables = [];\n\t\t\t_skrollableIdCounter = 0;\n\n\t\t\telements = document.getElementsByTagName('*');\n\t\t} else if(elements.length === undefined) {\n\t\t\t//We also accept a single element as parameter.\n\t\t\telements = [elements];\n\t\t}\n\n\t\telementIndex = 0;\n\t\telementsLength = elements.length;\n\n\t\tfor(; elementIndex < elementsLength; elementIndex++) {\n\t\t\tvar el = elements[elementIndex];\n\t\t\tvar anchorTarget = el;\n\t\t\tvar keyFrames = [];\n\n\t\t\t//If this particular element should be smooth scrolled.\n\t\t\tvar smoothScrollThis = _smoothScrollingEnabled;\n\n\t\t\t//The edge strategy for this particular element.\n\t\t\tvar edgeStrategy = _edgeStrategy;\n\n\t\t\t//If this particular element should emit keyframe events.\n\t\t\tvar emitEvents = false;\n\n\t\t\t//If we're reseting the counter, remove any old element ids that may be hanging around.\n\t\t\tif(ignoreID && SKROLLABLE_ID_DOM_PROPERTY in el) {\n\t\t\t\tdelete el[SKROLLABLE_ID_DOM_PROPERTY];\n\t\t\t}\n\n\t\t\tif(!el.attributes) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//Iterate over all attributes and search for key frame attributes.\n\t\t\tvar attributeIndex = 0;\n\t\t\tvar attributesLength = el.attributes.length;\n\n\t\t\tfor (; attributeIndex < attributesLength; attributeIndex++) {\n\t\t\t\tvar attr = el.attributes[attributeIndex];\n\n\t\t\t\tif(attr.name === 'data-anchor-target') {\n\t\t\t\t\tanchorTarget = document.querySelector(attr.value);\n\n\t\t\t\t\tif(anchorTarget === null) {\n\t\t\t\t\t\tthrow 'Unable to find anchor target \"' + attr.value + '\"';\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//Global smooth scrolling can be overridden by the element attribute.\n\t\t\t\tif(attr.name === 'data-smooth-scrolling') {\n\t\t\t\t\tsmoothScrollThis = attr.value !== 'off';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//Global edge strategy can be overridden by the element attribute.\n\t\t\t\tif(attr.name === 'data-edge-strategy') {\n\t\t\t\t\tedgeStrategy = attr.value;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//Is this element tagged with the `data-emit-events` attribute?\n\t\t\t\tif(attr.name === 'data-emit-events') {\n\t\t\t\t\temitEvents = true;\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar match = attr.name.match(rxKeyframeAttribute);\n\n\t\t\t\tif(match === null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar kf = {\n\t\t\t\t\tprops: attr.value,\n\t\t\t\t\t//Point back to the element as well.\n\t\t\t\t\telement: el,\n\t\t\t\t\t//The name of the event which this keyframe will fire, if emitEvents is\n\t\t\t\t\teventType: attr.name.replace(rxCamelCase, rxCamelCaseFn)\n\t\t\t\t};\n\n\t\t\t\tkeyFrames.push(kf);\n\n\t\t\t\tvar constant = match[1];\n\n\t\t\t\tif(constant) {\n\t\t\t\t\t//Strip the underscore prefix.\n\t\t\t\t\tkf.constant = constant.substr(1);\n\t\t\t\t}\n\n\t\t\t\t//Get the key frame offset.\n\t\t\t\tvar offset = match[2];\n\n\t\t\t\t//Is it a percentage offset?\n\t\t\t\tif(/p$/.test(offset)) {\n\t\t\t\t\tkf.isPercentage = true;\n\t\t\t\t\tkf.offset = (offset.slice(0, -1) | 0) / 100;\n\t\t\t\t} else {\n\t\t\t\t\tkf.offset = (offset | 0);\n\t\t\t\t}\n\n\t\t\t\tvar anchor1 = match[3];\n\n\t\t\t\t//If second anchor is not set, the first will be taken for both.\n\t\t\t\tvar anchor2 = match[4] || anchor1;\n\n\t\t\t\t//\"absolute\" (or \"classic\") mode, where numbers mean absolute scroll offset.\n\t\t\t\tif(!anchor1 || anchor1 === ANCHOR_START || anchor1 === ANCHOR_END) {\n\t\t\t\t\tkf.mode = 'absolute';\n\n\t\t\t\t\t//data-end needs to be calculated after all key frames are known.\n\t\t\t\t\tif(anchor1 === ANCHOR_END) {\n\t\t\t\t\t\tkf.isEnd = true;\n\t\t\t\t\t} else if(!kf.isPercentage) {\n\t\t\t\t\t\t//For data-start we can already set the key frame w/o calculations.\n\t\t\t\t\t\t//#59: \"scale\" options should only affect absolute mode.\n\t\t\t\t\t\tkf.offset = kf.offset * _scale;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//\"relative\" mode, where numbers are relative to anchors.\n\t\t\t\telse {\n\t\t\t\t\tkf.mode = 'relative';\n\t\t\t\t\tkf.anchors = [anchor1, anchor2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Does this element have key frames?\n\t\t\tif(!keyFrames.length) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//Will hold the original style and class attributes before we controlled the element (see #80).\n\t\t\tvar styleAttr, classAttr;\n\n\t\t\tvar id;\n\n\t\t\tif(!ignoreID && SKROLLABLE_ID_DOM_PROPERTY in el) {\n\t\t\t\t//We already have this element under control. Grab the corresponding skrollable id.\n\t\t\t\tid = el[SKROLLABLE_ID_DOM_PROPERTY];\n\t\t\t\tstyleAttr = _skrollables[id].styleAttr;\n\t\t\t\tclassAttr = _skrollables[id].classAttr;\n\t\t\t} else {\n\t\t\t\t//It's an unknown element. Asign it a new skrollable id.\n\t\t\t\tid = (el[SKROLLABLE_ID_DOM_PROPERTY] = _skrollableIdCounter++);\n\t\t\t\tstyleAttr = el.style.cssText;\n\t\t\t\tclassAttr = _getClass(el);\n\t\t\t}\n\n\t\t\t_skrollables[id] = {\n\t\t\t\telement: el,\n\t\t\t\tstyleAttr: styleAttr,\n\t\t\t\tclassAttr: classAttr,\n\t\t\t\tanchorTarget: anchorTarget,\n\t\t\t\tkeyFrames: keyFrames,\n\t\t\t\tsmoothScrolling: smoothScrollThis,\n\t\t\t\tedgeStrategy: edgeStrategy,\n\t\t\t\temitEvents: emitEvents,\n\t\t\t\tlastFrameIndex: -1\n\t\t\t};\n\n\t\t\t_updateClass(el, [SKROLLABLE_CLASS], []);\n\t\t}\n\n\t\t//Reflow for the first time.\n\t\t_reflow();\n\n\t\t//Now that we got all key frame numbers right, actually parse the properties.\n\t\telementIndex = 0;\n\t\telementsLength = elements.length;\n\n\t\tfor(; elementIndex < elementsLength; elementIndex++) {\n\t\t\tvar sk = _skrollables[elements[elementIndex][SKROLLABLE_ID_DOM_PROPERTY]];\n\n\t\t\tif(sk === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//Parse the property string to objects\n\t\t\t_parseProps(sk);\n\n\t\t\t//Fill key frames with missing properties from left and right\n\t\t\t_fillProps(sk);\n\t\t}\n\n\t\treturn _instance;\n\t};\n\n\t/**\n\t * Transform \"relative\" mode to \"absolute\" mode.\n\t * That is, calculate anchor position and offset of element.\n\t */\n\tSkrollr.prototype.relativeToAbsolute = function(element, viewportAnchor, elementAnchor) {\n\t\tvar viewportHeight = documentElement.clientHeight;\n\t\tvar box = element.getBoundingClientRect();\n\t\tvar absolute = box.top;\n\n\t\t//#100: IE doesn't supply \"height\" with getBoundingClientRect.\n\t\tvar boxHeight = box.bottom - box.top;\n\n\t\tif(viewportAnchor === ANCHOR_BOTTOM) {\n\t\t\tabsolute -= viewportHeight;\n\t\t} else if(viewportAnchor === ANCHOR_CENTER) {\n\t\t\tabsolute -= viewportHeight / 2;\n\t\t}\n\n\t\tif(elementAnchor === ANCHOR_BOTTOM) {\n\t\t\tabsolute += boxHeight;\n\t\t} else if(elementAnchor === ANCHOR_CENTER) {\n\t\t\tabsolute += boxHeight / 2;\n\t\t}\n\n\t\t//Compensate scrolling since getBoundingClientRect is relative to viewport.\n\t\tabsolute += _instance.getScrollTop();\n\n\t\treturn (absolute + 0.5) | 0;\n\t};\n\n\t/**\n\t * Animates scroll top to new position.\n\t */\n\tSkrollr.prototype.animateTo = function(top, options) {\n\t\toptions = options || {};\n\n\t\tvar now = _now();\n\t\tvar scrollTop = _instance.getScrollTop();\n\t\tvar duration = options.duration === undefined ? DEFAULT_DURATION : options.duration;\n\n\t\t//Setting this to a new value will automatically cause the current animation to stop, if any.\n\t\t_scrollAnimation = {\n\t\t\tstartTop: scrollTop,\n\t\t\ttopDiff: top - scrollTop,\n\t\t\ttargetTop: top,\n\t\t\tduration: duration,\n\t\t\tstartTime: now,\n\t\t\tendTime: now + duration,\n\t\t\teasing: easings[options.easing || DEFAULT_EASING],\n\t\t\tdone: options.done\n\t\t};\n\n\t\t//Don't queue the animation if there's nothing to animate.\n\t\tif(!_scrollAnimation.topDiff) {\n\t\t\tif(_scrollAnimation.done) {\n\t\t\t\t_scrollAnimation.done.call(_instance, false);\n\t\t\t}\n\n\t\t\t_scrollAnimation = undefined;\n\t\t}\n\n\t\treturn _instance;\n\t};\n\n\t/**\n\t * Stops animateTo animation.\n\t */\n\tSkrollr.prototype.stopAnimateTo = function() {\n\t\tif(_scrollAnimation && _scrollAnimation.done) {\n\t\t\t_scrollAnimation.done.call(_instance, true);\n\t\t}\n\n\t\t_scrollAnimation = undefined;\n\t};\n\n\t/**\n\t * Returns if an animation caused by animateTo is currently running.\n\t */\n\tSkrollr.prototype.isAnimatingTo = function() {\n\t\treturn !!_scrollAnimation;\n\t};\n\n\tSkrollr.prototype.isMobile = function() {\n\t\treturn _isMobile;\n\t};\n\n\tSkrollr.prototype.setScrollTop = function(top, force) {\n\t\t_forceRender = (force === true);\n\n\t\tif(_isMobile) {\n\t\t\t_mobileOffset = Math.min(Math.max(top, 0), _maxKeyFrame);\n\t\t} else {\n\t\t\twindow.scrollTo(0, top);\n\t\t}\n\n\t\treturn _instance;\n\t};\n\n\tSkrollr.prototype.getScrollTop = function() {\n\t\tif(_isMobile) {\n\t\t\treturn _mobileOffset;\n\t\t} else {\n\t\t\treturn window.pageYOffset || documentElement.scrollTop || body.scrollTop || 0;\n\t\t}\n\t};\n\n\tSkrollr.prototype.getMaxScrollTop = function() {\n\t\treturn _maxKeyFrame;\n\t};\n\n\tSkrollr.prototype.on = function(name, fn) {\n\t\t_listeners[name] = fn;\n\n\t\treturn _instance;\n\t};\n\n\tSkrollr.prototype.off = function(name) {\n\t\tdelete _listeners[name];\n\n\t\treturn _instance;\n\t};\n\n\tSkrollr.prototype.destroy = function() {\n\t\tvar cancelAnimFrame = polyfillCAF();\n\t\tcancelAnimFrame(_animFrame);\n\t\t_removeAllEvents();\n\n\t\t_updateClass(documentElement, [NO_SKROLLR_CLASS], [SKROLLR_CLASS, SKROLLR_DESKTOP_CLASS, SKROLLR_MOBILE_CLASS]);\n\n\t\tvar skrollableIndex = 0;\n\t\tvar skrollablesLength = _skrollables.length;\n\n\t\tfor(; skrollableIndex < skrollablesLength; skrollableIndex++) {\n\t\t\t_reset(_skrollables[skrollableIndex].element);\n\t\t}\n\n\t\tdocumentElement.style.overflow = body.style.overflow = '';\n\t\tdocumentElement.style.height = body.style.height = '';\n\n\t\tif(_skrollrBody) {\n\t\t\tskrollr.setStyle(_skrollrBody, 'transform', 'none');\n\t\t}\n\n\t\t_instance = undefined;\n\t\t_skrollrBody = undefined;\n\t\t_listeners = undefined;\n\t\t_forceHeight = undefined;\n\t\t_maxKeyFrame = 0;\n\t\t_scale = 1;\n\t\t_constants = undefined;\n\t\t_mobileDeceleration = undefined;\n\t\t_direction = 'down';\n\t\t_lastTop = -1;\n\t\t_lastViewportWidth = 0;\n\t\t_lastViewportHeight = 0;\n\t\t_requestReflow = false;\n\t\t_scrollAnimation = undefined;\n\t\t_smoothScrollingEnabled = undefined;\n\t\t_smoothScrollingDuration = undefined;\n\t\t_smoothScrolling = undefined;\n\t\t_forceRender = undefined;\n\t\t_skrollableIdCounter = 0;\n\t\t_edgeStrategy = undefined;\n\t\t_isMobile = false;\n\t\t_mobileOffset = 0;\n\t\t_translateZ = undefined;\n\t};\n\n\t/*\n\t\tPrivate methods.\n\t*/\n\n\tvar _initMobile = function() {\n\t\tvar initialElement;\n\t\tvar initialTouchY;\n\t\tvar initialTouchX;\n\t\tvar currentElement;\n\t\tvar currentTouchY;\n\t\tvar currentTouchX;\n\t\tvar lastTouchY;\n\t\tvar deltaY;\n\n\t\tvar initialTouchTime;\n\t\tvar currentTouchTime;\n\t\tvar lastTouchTime;\n\t\tvar deltaTime;\n\n\t\t_addEvent(documentElement, [EVENT_TOUCHSTART, EVENT_TOUCHMOVE, EVENT_TOUCHCANCEL, EVENT_TOUCHEND].join(' '), function(e) {\n\t\t\tvar touch = e.changedTouches[0];\n\n\t\t\tcurrentElement = e.target;\n\n\t\t\t//We don't want text nodes.\n\t\t\twhile(currentElement.nodeType === 3) {\n\t\t\t\tcurrentElement = currentElement.parentNode;\n\t\t\t}\n\n\t\t\tcurrentTouchY = touch.clientY;\n\t\t\tcurrentTouchX = touch.clientX;\n\t\t\tcurrentTouchTime = e.timeStamp;\n\n\t\t\tif(!rxTouchIgnoreTags.test(currentElement.tagName)) {\n\t\t\t\te.preventDefault();\n\t\t\t}\n\n\t\t\tswitch(e.type) {\n\t\t\t\tcase EVENT_TOUCHSTART:\n\t\t\t\t\t//The last element we tapped on.\n\t\t\t\t\tif(initialElement) {\n\t\t\t\t\t\tinitialElement.blur();\n\t\t\t\t\t}\n\n\t\t\t\t\t_instance.stopAnimateTo();\n\n\t\t\t\t\tinitialElement = currentElement;\n\n\t\t\t\t\tinitialTouchY = lastTouchY = currentTouchY;\n\t\t\t\t\tinitialTouchX = currentTouchX;\n\t\t\t\t\tinitialTouchTime = currentTouchTime;\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase EVENT_TOUCHMOVE:\n\t\t\t\t\t//Prevent default event on touchIgnore elements in case they don't have focus yet.\n\t\t\t\t\tif(rxTouchIgnoreTags.test(currentElement.tagName) && document.activeElement !== currentElement) {\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t}\n\n\t\t\t\t\tdeltaY = currentTouchY - lastTouchY;\n\t\t\t\t\tdeltaTime = currentTouchTime - lastTouchTime;\n\n\t\t\t\t\t_instance.setScrollTop(_mobileOffset - deltaY, true);\n\n\t\t\t\t\tlastTouchY = currentTouchY;\n\t\t\t\t\tlastTouchTime = currentTouchTime;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tcase EVENT_TOUCHCANCEL:\n\t\t\t\tcase EVENT_TOUCHEND:\n\t\t\t\t\tvar distanceY = initialTouchY - currentTouchY;\n\t\t\t\t\tvar distanceX = initialTouchX - currentTouchX;\n\t\t\t\t\tvar distance2 = distanceX * distanceX + distanceY * distanceY;\n\n\t\t\t\t\t//Check if it was more like a tap (moved less than 7px).\n\t\t\t\t\tif(distance2 < 49) {\n\t\t\t\t\t\tif(!rxTouchIgnoreTags.test(initialElement.tagName)) {\n\t\t\t\t\t\t\tinitialElement.focus();\n\n\t\t\t\t\t\t\t//It was a tap, click the element.\n\t\t\t\t\t\t\tvar clickEvent = document.createEvent('MouseEvents');\n\t\t\t\t\t\t\tclickEvent.initMouseEvent('click', true, true, e.view, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);\n\t\t\t\t\t\t\tinitialElement.dispatchEvent(clickEvent);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tinitialElement = undefined;\n\n\t\t\t\t\tvar speed = deltaY / deltaTime;\n\n\t\t\t\t\t//Cap speed at 3 pixel/ms.\n\t\t\t\t\tspeed = Math.max(Math.min(speed, 3), -3);\n\n\t\t\t\t\tvar duration = Math.abs(speed / _mobileDeceleration);\n\t\t\t\t\tvar targetOffset = speed * duration + 0.5 * _mobileDeceleration * duration * duration;\n\t\t\t\t\tvar targetTop = _instance.getScrollTop() - targetOffset;\n\n\t\t\t\t\t//Relative duration change for when scrolling above bounds.\n\t\t\t\t\tvar targetRatio = 0;\n\n\t\t\t\t\t//Change duration proportionally when scrolling would leave bounds.\n\t\t\t\t\tif(targetTop > _maxKeyFrame) {\n\t\t\t\t\t\ttargetRatio = (_maxKeyFrame - targetTop) / targetOffset;\n\n\t\t\t\t\t\ttargetTop = _maxKeyFrame;\n\t\t\t\t\t} else if(targetTop < 0) {\n\t\t\t\t\t\ttargetRatio = -targetTop / targetOffset;\n\n\t\t\t\t\t\ttargetTop = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tduration = duration * (1 - targetRatio);\n\n\t\t\t\t\t_instance.animateTo((targetTop + 0.5) | 0, {easing: 'outCubic', duration: duration});\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\t//Just in case there has already been some native scrolling, reset it.\n\t\twindow.scrollTo(0, 0);\n\t\tdocumentElement.style.overflow = body.style.overflow = 'hidden';\n\t};\n\n\t/**\n\t * Updates key frames which depend on others / need to be updated on resize.\n\t * That is \"end\" in \"absolute\" mode and all key frames in \"relative\" mode.\n\t * Also handles constants, because they may change on resize.\n\t */\n\tvar _updateDependentKeyFrames = function() {\n\t\tvar viewportHeight = documentElement.clientHeight;\n\t\tvar processedConstants = _processConstants();\n\t\tvar skrollable;\n\t\tvar element;\n\t\tvar anchorTarget;\n\t\tvar keyFrames;\n\t\tvar keyFrameIndex;\n\t\tvar keyFramesLength;\n\t\tvar kf;\n\t\tvar skrollableIndex;\n\t\tvar skrollablesLength;\n\t\tvar offset;\n\t\tvar constantValue;\n\n\t\t//First process all relative-mode elements and find the max key frame.\n\t\tskrollableIndex = 0;\n\t\tskrollablesLength = _skrollables.length;\n\n\t\tfor(; skrollableIndex < skrollablesLength; skrollableIndex++) {\n\t\t\tskrollable = _skrollables[skrollableIndex];\n\t\t\telement = skrollable.element;\n\t\t\tanchorTarget = skrollable.anchorTarget;\n\t\t\tkeyFrames = skrollable.keyFrames;\n\n\t\t\tkeyFrameIndex = 0;\n\t\t\tkeyFramesLength = keyFrames.length;\n\n\t\t\tfor(; keyFrameIndex < keyFramesLength; keyFrameIndex++) {\n\t\t\t\tkf = keyFrames[keyFrameIndex];\n\n\t\t\t\toffset = kf.offset;\n\t\t\t\tconstantValue = processedConstants[kf.constant] || 0;\n\n\t\t\t\tkf.frame = offset;\n\n\t\t\t\tif(kf.isPercentage) {\n\t\t\t\t\t//Convert the offset to percentage of the viewport height.\n\t\t\t\t\toffset = offset * viewportHeight;\n\n\t\t\t\t\t//Absolute + percentage mode.\n\t\t\t\t\tkf.frame = offset;\n\t\t\t\t}\n\n\t\t\t\tif(kf.mode === 'relative') {\n\t\t\t\t\t_reset(element);\n\n\t\t\t\t\tkf.frame = _instance.relativeToAbsolute(anchorTarget, kf.anchors[0], kf.anchors[1]) - offset;\n\n\t\t\t\t\t_reset(element, true);\n\t\t\t\t}\n\n\t\t\t\tkf.frame += constantValue;\n\n\t\t\t\t//Only search for max key frame when forceHeight is enabled.\n\t\t\t\tif(_forceHeight) {\n\t\t\t\t\t//Find the max key frame, but don't use one of the data-end ones for comparison.\n\t\t\t\t\tif(!kf.isEnd && kf.frame > _maxKeyFrame) {\n\t\t\t\t\t\t_maxKeyFrame = kf.frame;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//#133: The document can be larger than the maxKeyFrame we found.\n\t\t_maxKeyFrame = Math.max(_maxKeyFrame, _getDocumentHeight());\n\n\t\t//Now process all data-end keyframes.\n\t\tskrollableIndex = 0;\n\t\tskrollablesLength = _skrollables.length;\n\n\t\tfor(; skrollableIndex < skrollablesLength; skrollableIndex++) {\n\t\t\tskrollable = _skrollables[skrollableIndex];\n\t\t\tkeyFrames = skrollable.keyFrames;\n\n\t\t\tkeyFrameIndex = 0;\n\t\t\tkeyFramesLength = keyFrames.length;\n\n\t\t\tfor(; keyFrameIndex < keyFramesLength; keyFrameIndex++) {\n\t\t\t\tkf = keyFrames[keyFrameIndex];\n\n\t\t\t\tconstantValue = processedConstants[kf.constant] || 0;\n\n\t\t\t\tif(kf.isEnd) {\n\t\t\t\t\tkf.frame = _maxKeyFrame - kf.offset + constantValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tskrollable.keyFrames.sort(_keyFrameComparator);\n\t\t}\n\t};\n\n\t/**\n\t * Calculates and sets the style properties for the element at the given frame.\n\t * @param fakeFrame The frame to render at when smooth scrolling is enabled.\n\t * @param actualFrame The actual frame we are at.\n\t */\n\tvar _calcSteps = function(fakeFrame, actualFrame) {\n\t\t//Iterate over all skrollables.\n\t\tvar skrollableIndex = 0;\n\t\tvar skrollablesLength = _skrollables.length;\n\n\t\tfor(; skrollableIndex < skrollablesLength; skrollableIndex++) {\n\t\t\tvar skrollable = _skrollables[skrollableIndex];\n\t\t\tvar element = skrollable.element;\n\t\t\tvar frame = skrollable.smoothScrolling ? fakeFrame : actualFrame;\n\t\t\tvar frames = skrollable.keyFrames;\n\t\t\tvar framesLength = frames.length;\n\t\t\tvar firstFrame = frames[0];\n\t\t\tvar lastFrame = frames[frames.length - 1];\n\t\t\tvar beforeFirst = frame < firstFrame.frame;\n\t\t\tvar afterLast = frame > lastFrame.frame;\n\t\t\tvar firstOrLastFrame = beforeFirst ? firstFrame : lastFrame;\n\t\t\tvar emitEvents = skrollable.emitEvents;\n\t\t\tvar lastFrameIndex = skrollable.lastFrameIndex;\n\t\t\tvar key;\n\t\t\tvar value;\n\n\t\t\t//If we are before/after the first/last frame, set the styles according to the given edge strategy.\n\t\t\tif(beforeFirst || afterLast) {\n\t\t\t\t//Check if we already handled this edge case last time.\n\t\t\t\t//Note: using setScrollTop it's possible that we jumped from one edge to the other.\n\t\t\t\tif(beforeFirst && skrollable.edge === -1 || afterLast && skrollable.edge === 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//Add the skrollr-before or -after class.\n\t\t\t\tif(beforeFirst) {\n\t\t\t\t\t_updateClass(element, [SKROLLABLE_BEFORE_CLASS], [SKROLLABLE_AFTER_CLASS, SKROLLABLE_BETWEEN_CLASS]);\n\n\t\t\t\t\t//This handles the special case where we exit the first keyframe.\n\t\t\t\t\tif(emitEvents && lastFrameIndex > -1) {\n\t\t\t\t\t\t_emitEvent(element, firstFrame.eventType, _direction);\n\t\t\t\t\t\tskrollable.lastFrameIndex = -1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t_updateClass(element, [SKROLLABLE_AFTER_CLASS], [SKROLLABLE_BEFORE_CLASS, SKROLLABLE_BETWEEN_CLASS]);\n\n\t\t\t\t\t//This handles the special case where we exit the last keyframe.\n\t\t\t\t\tif(emitEvents && lastFrameIndex < framesLength) {\n\t\t\t\t\t\t_emitEvent(element, lastFrame.eventType, _direction);\n\t\t\t\t\t\tskrollable.lastFrameIndex = framesLength;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Remember that we handled the edge case (before/after the first/last keyframe).\n\t\t\t\tskrollable.edge = beforeFirst ? -1 : 1;\n\n\t\t\t\tswitch(skrollable.edgeStrategy) {\n\t\t\t\t\tcase 'reset':\n\t\t\t\t\t\t_reset(element);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tcase 'ease':\n\t\t\t\t\t\t//Handle this case like it would be exactly at first/last keyframe and just pass it on.\n\t\t\t\t\t\tframe = firstOrLastFrame.frame;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase 'set':\n\t\t\t\t\t\tvar props = firstOrLastFrame.props;\n\n\t\t\t\t\t\tfor(key in props) {\n\t\t\t\t\t\t\tif(hasProp.call(props, key)) {\n\t\t\t\t\t\t\t\tvalue = _interpolateString(props[key].value);\n\n\t\t\t\t\t\t\t\t//Set style or attribute.\n\t\t\t\t\t\t\t\tif(key.indexOf('@') === 0) {\n\t\t\t\t\t\t\t\t\telement.setAttribute(key.substr(1), value);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tskrollr.setStyle(element, key, value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//Did we handle an edge last time?\n\t\t\t\tif(skrollable.edge !== 0) {\n\t\t\t\t\t_updateClass(element, [SKROLLABLE_CLASS, SKROLLABLE_BETWEEN_CLASS], [SKROLLABLE_BEFORE_CLASS, SKROLLABLE_AFTER_CLASS]);\n\t\t\t\t\tskrollable.edge = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Find out between which two key frames we are right now.\n\t\t\tvar keyFrameIndex = 0;\n\n\t\t\tfor(; keyFrameIndex < framesLength - 1; keyFrameIndex++) {\n\t\t\t\tif(frame >= frames[keyFrameIndex].frame && frame <= frames[keyFrameIndex + 1].frame) {\n\t\t\t\t\tvar left = frames[keyFrameIndex];\n\t\t\t\t\tvar right = frames[keyFrameIndex + 1];\n\n\t\t\t\t\tfor(key in left.props) {\n\t\t\t\t\t\tif(hasProp.call(left.props, key)) {\n\t\t\t\t\t\t\tvar progress = (frame - left.frame) / (right.frame - left.frame);\n\n\t\t\t\t\t\t\t//Transform the current progress using the given easing function.\n\t\t\t\t\t\t\tprogress = left.props[key].easing(progress);\n\n\t\t\t\t\t\t\t//Interpolate between the two values\n\t\t\t\t\t\t\tvalue = _calcInterpolation(left.props[key].value, right.props[key].value, progress);\n\n\t\t\t\t\t\t\tvalue = _interpolateString(value);\n\n\t\t\t\t\t\t\t//Set style or attribute.\n\t\t\t\t\t\t\tif(key.indexOf('@') === 0) {\n\t\t\t\t\t\t\t\telement.setAttribute(key.substr(1), value);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tskrollr.setStyle(element, key, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//Are events enabled on this element?\n\t\t\t\t\t//This code handles the usual cases of scrolling through different keyframes.\n\t\t\t\t\t//The special cases of before first and after last keyframe are handled above.\n\t\t\t\t\tif(emitEvents) {\n\t\t\t\t\t\t//Did we pass a new keyframe?\n\t\t\t\t\t\tif(lastFrameIndex !== keyFrameIndex) {\n\t\t\t\t\t\t\tif(_direction === 'down') {\n\t\t\t\t\t\t\t\t_emitEvent(element, left.eventType, _direction);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t_emitEvent(element, right.eventType, _direction);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tskrollable.lastFrameIndex = keyFrameIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Renders all elements.\n\t */\n\tvar _render = function() {\n\t\tif(_requestReflow) {\n\t\t\t_requestReflow = false;\n\t\t\t_reflow();\n\t\t}\n\n\t\t//We may render something else than the actual scrollbar position.\n\t\tvar renderTop = _instance.getScrollTop();\n\n\t\t//If there's an animation, which ends in current render call, call the callback after rendering.\n\t\tvar afterAnimationCallback;\n\t\tvar now = _now();\n\t\tvar progress;\n\n\t\t//Before actually rendering handle the scroll animation, if any.\n\t\tif(_scrollAnimation) {\n\t\t\t//It's over\n\t\t\tif(now >= _scrollAnimation.endTime) {\n\t\t\t\trenderTop = _scrollAnimation.targetTop;\n\t\t\t\tafterAnimationCallback = _scrollAnimation.done;\n\t\t\t\t_scrollAnimation = undefined;\n\t\t\t} else {\n\t\t\t\t//Map the current progress to the new progress using given easing function.\n\t\t\t\tprogress = _scrollAnimation.easing((now - _scrollAnimation.startTime) / _scrollAnimation.duration);\n\n\t\t\t\trenderTop = (_scrollAnimation.startTop + progress * _scrollAnimation.topDiff) | 0;\n\t\t\t}\n\n\t\t\t_instance.setScrollTop(renderTop, true);\n\t\t}\n\t\t//Smooth scrolling only if there's no animation running and if we're not forcing the rendering.\n\t\telse if(!_forceRender) {\n\t\t\tvar smoothScrollingDiff = _smoothScrolling.targetTop - renderTop;\n\n\t\t\t//The user scrolled, start new smooth scrolling.\n\t\t\tif(smoothScrollingDiff) {\n\t\t\t\t_smoothScrolling = {\n\t\t\t\t\tstartTop: _lastTop,\n\t\t\t\t\ttopDiff: renderTop - _lastTop,\n\t\t\t\t\ttargetTop: renderTop,\n\t\t\t\t\tstartTime: _lastRenderCall,\n\t\t\t\t\tendTime: _lastRenderCall + _smoothScrollingDuration\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t//Interpolate the internal scroll position (not the actual scrollbar).\n\t\t\tif(now <= _smoothScrolling.endTime) {\n\t\t\t\t//Map the current progress to the new progress using easing function.\n\t\t\t\tprogress = easings.sqrt((now - _smoothScrolling.startTime) / _smoothScrollingDuration);\n\n\t\t\t\trenderTop = (_smoothScrolling.startTop + progress * _smoothScrolling.topDiff) | 0;\n\t\t\t}\n\t\t}\n\n\t\t//Did the scroll position even change?\n\t\tif(_forceRender || _lastTop !== renderTop) {\n\t\t\t//Remember in which direction are we scrolling?\n\t\t\t_direction = (renderTop > _lastTop) ? 'down' : (renderTop < _lastTop ? 'up' : _direction);\n\n\t\t\t_forceRender = false;\n\n\t\t\tvar listenerParams = {\n\t\t\t\tcurTop: renderTop,\n\t\t\t\tlastTop: _lastTop,\n\t\t\t\tmaxTop: _maxKeyFrame,\n\t\t\t\tdirection: _direction\n\t\t\t};\n\n\t\t\t//Tell the listener we are about to render.\n\t\t\tvar continueRendering = _listeners.beforerender && _listeners.beforerender.call(_instance, listenerParams);\n\n\t\t\t//The beforerender listener function is able the cancel rendering.\n\t\t\tif(continueRendering !== false) {\n\t\t\t\t//Now actually interpolate all the styles.\n\t\t\t\t_calcSteps(renderTop, _instance.getScrollTop());\n\n\t\t\t\t//That's were we actually \"scroll\" on mobile.\n\t\t\t\tif(_isMobile && _skrollrBody) {\n\t\t\t\t\t//Set the transform (\"scroll it\").\n\t\t\t\t\tskrollr.setStyle(_skrollrBody, 'transform', 'translate(0, ' + -(_mobileOffset) + 'px) ' + _translateZ);\n\t\t\t\t}\n\n\t\t\t\t//Remember when we last rendered.\n\t\t\t\t_lastTop = renderTop;\n\n\t\t\t\tif(_listeners.render) {\n\t\t\t\t\t_listeners.render.call(_instance, listenerParams);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(afterAnimationCallback) {\n\t\t\t\tafterAnimationCallback.call(_instance, false);\n\t\t\t}\n\t\t}\n\n\t\t_lastRenderCall = now;\n\t};\n\n\t/**\n\t * Parses the properties for each key frame of the given skrollable.\n\t */\n\tvar _parseProps = function(skrollable) {\n\t\t//Iterate over all key frames\n\t\tvar keyFrameIndex = 0;\n\t\tvar keyFramesLength = skrollable.keyFrames.length;\n\n\t\tfor(; keyFrameIndex < keyFramesLength; keyFrameIndex++) {\n\t\t\tvar frame = skrollable.keyFrames[keyFrameIndex];\n\t\t\tvar easing;\n\t\t\tvar value;\n\t\t\tvar prop;\n\t\t\tvar props = {};\n\n\t\t\tvar match;\n\n\t\t\twhile((match = rxPropValue.exec(frame.props)) !== null) {\n\t\t\t\tprop = match[1];\n\t\t\t\tvalue = match[2];\n\n\t\t\t\teasing = prop.match(rxPropEasing);\n\n\t\t\t\t//Is there an easing specified for this prop?\n\t\t\t\tif(easing !== null) {\n\t\t\t\t\tprop = easing[1];\n\t\t\t\t\teasing = easing[2];\n\t\t\t\t} else {\n\t\t\t\t\teasing = DEFAULT_EASING;\n\t\t\t\t}\n\n\t\t\t\t//Exclamation point at first position forces the value to be taken literal.\n\t\t\t\tvalue = value.indexOf('!') ? _parseProp(value) : [value.slice(1)];\n\n\t\t\t\t//Save the prop for this key frame with his value and easing function\n\t\t\t\tprops[prop] = {\n\t\t\t\t\tvalue: value,\n\t\t\t\t\teasing: easings[easing]\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tframe.props = props;\n\t\t}\n\t};\n\n\t/**\n\t * Parses a value extracting numeric values and generating a format string\n\t * for later interpolation of the new values in old string.\n\t *\n\t * @param val The CSS value to be parsed.\n\t * @return Something like [\"rgba(?%,?%, ?%,?)\", 100, 50, 0, .7]\n\t * where the first element is the format string later used\n\t * and all following elements are the numeric value.\n\t */\n\tvar _parseProp = function(val) {\n\t\tvar numbers = [];\n\n\t\t//One special case, where floats don't work.\n\t\t//We replace all occurences of rgba colors\n\t\t//which don't use percentage notation with the percentage notation.\n\t\trxRGBAIntegerColor.lastIndex = 0;\n\t\tval = val.replace(rxRGBAIntegerColor, function(rgba) {\n\t\t\treturn rgba.replace(rxNumericValue, function(n) {\n\t\t\t\treturn n / 255 * 100 + '%';\n\t\t\t});\n\t\t});\n\n\t\t//Handle prefixing of \"gradient\" values.\n\t\t//For now only the prefixed value will be set. Unprefixed isn't supported anyway.\n\t\tif(theDashedCSSPrefix) {\n\t\t\trxGradient.lastIndex = 0;\n\t\t\tval = val.replace(rxGradient, function(s) {\n\t\t\t\treturn theDashedCSSPrefix + s;\n\t\t\t});\n\t\t}\n\n\t\t//Now parse ANY number inside this string and create a format string.\n\t\tval = val.replace(rxNumericValue, function(n) {\n\t\t\tnumbers.push(+n);\n\t\t\treturn '{?}';\n\t\t});\n\n\t\t//Add the formatstring as first value.\n\t\tnumbers.unshift(val);\n\n\t\treturn numbers;\n\t};\n\n\t/**\n\t * Fills the key frames with missing left and right hand properties.\n\t * If key frame 1 has property X and key frame 2 is missing X,\n\t * but key frame 3 has X again, then we need to assign X to key frame 2 too.\n\t *\n\t * @param sk A skrollable.\n\t */\n\tvar _fillProps = function(sk) {\n\t\t//Will collect the properties key frame by key frame\n\t\tvar propList = {};\n\t\tvar keyFrameIndex;\n\t\tvar keyFramesLength;\n\n\t\t//Iterate over all key frames from left to right\n\t\tkeyFrameIndex = 0;\n\t\tkeyFramesLength = sk.keyFrames.length;\n\n\t\tfor(; keyFrameIndex < keyFramesLength; keyFrameIndex++) {\n\t\t\t_fillPropForFrame(sk.keyFrames[keyFrameIndex], propList);\n\t\t}\n\n\t\t//Now do the same from right to fill the last gaps\n\n\t\tpropList = {};\n\n\t\t//Iterate over all key frames from right to left\n\t\tkeyFrameIndex = sk.keyFrames.length - 1;\n\n\t\tfor(; keyFrameIndex >= 0; keyFrameIndex--) {\n\t\t\t_fillPropForFrame(sk.keyFrames[keyFrameIndex], propList);\n\t\t}\n\t};\n\n\tvar _fillPropForFrame = function(frame, propList) {\n\t\tvar key;\n\n\t\t//For each key frame iterate over all right hand properties and assign them,\n\t\t//but only if the current key frame doesn't have the property by itself\n\t\tfor(key in propList) {\n\t\t\t//The current frame misses this property, so assign it.\n\t\t\tif(!hasProp.call(frame.props, key)) {\n\t\t\t\tframe.props[key] = propList[key];\n\t\t\t}\n\t\t}\n\n\t\t//Iterate over all props of the current frame and collect them\n\t\tfor(key in frame.props) {\n\t\t\tpropList[key] = frame.props[key];\n\t\t}\n\t};\n\n\t/**\n\t * Calculates the new values for two given values array.\n\t */\n\tvar _calcInterpolation = function(val1, val2, progress) {\n\t\tvar valueIndex;\n\t\tvar val1Length = val1.length;\n\n\t\t//They both need to have the same length\n\t\tif(val1Length !== val2.length) {\n\t\t\tthrow 'Can\\'t interpolate between \"' + val1[0] + '\" and \"' + val2[0] + '\"';\n\t\t}\n\n\t\t//Add the format string as first element.\n\t\tvar interpolated = [val1[0]];\n\n\t\tvalueIndex = 1;\n\n\t\tfor(; valueIndex < val1Length; valueIndex++) {\n\t\t\t//That's the line where the two numbers are actually interpolated.\n\t\t\tinterpolated[valueIndex] = val1[valueIndex] + ((val2[valueIndex] - val1[valueIndex]) * progress);\n\t\t}\n\n\t\treturn interpolated;\n\t};\n\n\t/**\n\t * Interpolates the numeric values into the format string.\n\t */\n\tvar _interpolateString = function(val) {\n\t\tvar valueIndex = 1;\n\n\t\trxInterpolateString.lastIndex = 0;\n\n\t\treturn val[0].replace(rxInterpolateString, function() {\n\t\t\treturn val[valueIndex++];\n\t\t});\n\t};\n\n\t/**\n\t * Resets the class and style attribute to what it was before skrollr manipulated the element.\n\t * Also remembers the values it had before reseting, in order to undo the reset.\n\t */\n\tvar _reset = function(elements, undo) {\n\t\t//We accept a single element or an array of elements.\n\t\telements = [].concat(elements);\n\n\t\tvar skrollable;\n\t\tvar element;\n\t\tvar elementsIndex = 0;\n\t\tvar elementsLength = elements.length;\n\n\t\tfor(; elementsIndex < elementsLength; elementsIndex++) {\n\t\t\telement = elements[elementsIndex];\n\t\t\tskrollable = _skrollables[element[SKROLLABLE_ID_DOM_PROPERTY]];\n\n\t\t\t//Couldn't find the skrollable for this DOM element.\n\t\t\tif(!skrollable) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(undo) {\n\t\t\t\t//Reset class and style to the \"dirty\" (set by skrollr) values.\n\t\t\t\telement.style.cssText = skrollable.dirtyStyleAttr;\n\t\t\t\t_updateClass(element, skrollable.dirtyClassAttr);\n\t\t\t} else {\n\t\t\t\t//Remember the \"dirty\" (set by skrollr) class and style.\n\t\t\t\tskrollable.dirtyStyleAttr = element.style.cssText;\n\t\t\t\tskrollable.dirtyClassAttr = _getClass(element);\n\n\t\t\t\t//Reset class and style to what it originally was.\n\t\t\t\telement.style.cssText = skrollable.styleAttr;\n\t\t\t\t_updateClass(element, skrollable.classAttr);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Detects support for 3d transforms by applying it to the skrollr-body.\n\t */\n\tvar _detect3DTransforms = function() {\n\t\t_translateZ = 'translateZ(0)';\n\t\tskrollr.setStyle(_skrollrBody, 'transform', _translateZ);\n\n\t\tvar computedStyle = getStyle(_skrollrBody);\n\t\tvar computedTransform = computedStyle.getPropertyValue('transform');\n\t\tvar computedTransformWithPrefix = computedStyle.getPropertyValue(theDashedCSSPrefix + 'transform');\n\t\tvar has3D = (computedTransform && computedTransform !== 'none') || (computedTransformWithPrefix && computedTransformWithPrefix !== 'none');\n\n\t\tif(!has3D) {\n\t\t\t_translateZ = '';\n\t\t}\n\t};\n\n\t/**\n\t * Set the CSS property on the given element. Sets prefixed properties as well.\n\t */\n\tskrollr.setStyle = function(el, prop, val) {\n\t\tvar style = el.style;\n\n\t\t//Camel case.\n\t\tprop = prop.replace(rxCamelCase, rxCamelCaseFn).replace('-', '');\n\n\t\t//Make sure z-index gets a <integer>.\n\t\t//This is the only <integer> case we need to handle.\n\t\tif(prop === 'zIndex') {\n\t\t\tif(isNaN(val)) {\n\t\t\t\t//If it's not a number, don't touch it.\n\t\t\t\t//It could for example be \"auto\" (#351).\n\t\t\t\tstyle[prop] = val;\n\t\t\t} else {\n\t\t\t\t//Floor the number.\n\t\t\t\tstyle[prop] = '' + (val | 0);\n\t\t\t}\n\t\t}\n\t\t//#64: \"float\" can't be set across browsers. Needs to use \"cssFloat\" for all except IE.\n\t\telse if(prop === 'float') {\n\t\t\tstyle.styleFloat = style.cssFloat = val;\n\t\t}\n\t\telse {\n\t\t\t//Need try-catch for old IE.\n\t\t\ttry {\n\t\t\t\t//Set prefixed property if there's a prefix.\n\t\t\t\tif(theCSSPrefix) {\n\t\t\t\t\tstyle[theCSSPrefix + prop.slice(0,1).toUpperCase() + prop.slice(1)] = val;\n\t\t\t\t}\n\n\t\t\t\t//Set unprefixed.\n\t\t\t\tstyle[prop] = val;\n\t\t\t} catch(ignore) {}\n\t\t}\n\t};\n\n\t/**\n\t * Cross browser event handling.\n\t */\n\tvar _addEvent = skrollr.addEvent = function(element, names, callback) {\n\t\tvar intermediate = function(e) {\n\t\t\t//Normalize IE event stuff.\n\t\t\te = e || window.event;\n\n\t\t\tif(!e.target) {\n\t\t\t\te.target = e.srcElement;\n\t\t\t}\n\n\t\t\tif(!e.preventDefault) {\n\t\t\t\te.preventDefault = function() {\n\t\t\t\t\te.returnValue = false;\n\t\t\t\t\te.defaultPrevented = true;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn callback.call(this, e);\n\t\t};\n\n\t\tnames = names.split(' ');\n\n\t\tvar name;\n\t\tvar nameCounter = 0;\n\t\tvar namesLength = names.length;\n\n\t\tfor(; nameCounter < namesLength; nameCounter++) {\n\t\t\tname = names[nameCounter];\n\n\t\t\tif(element.addEventListener) {\n\t\t\t\telement.addEventListener(name, callback, false);\n\t\t\t} else {\n\t\t\t\telement.attachEvent('on' + name, intermediate);\n\t\t\t}\n\n\t\t\t//Remember the events to be able to flush them later.\n\t\t\t_registeredEvents.push({\n\t\t\t\telement: element,\n\t\t\t\tname: name,\n\t\t\t\tlistener: callback\n\t\t\t});\n\t\t}\n\t};\n\n\tvar _removeEvent = skrollr.removeEvent = function(element, names, callback) {\n\t\tnames = names.split(' ');\n\n\t\tvar nameCounter = 0;\n\t\tvar namesLength = names.length;\n\n\t\tfor(; nameCounter < namesLength; nameCounter++) {\n\t\t\tif(element.removeEventListener) {\n\t\t\t\telement.removeEventListener(names[nameCounter], callback, false);\n\t\t\t} else {\n\t\t\t\telement.detachEvent('on' + names[nameCounter], callback);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar _removeAllEvents = function() {\n\t\tvar eventData;\n\t\tvar eventCounter = 0;\n\t\tvar eventsLength = _registeredEvents.length;\n\n\t\tfor(; eventCounter < eventsLength; eventCounter++) {\n\t\t\teventData = _registeredEvents[eventCounter];\n\n\t\t\t_removeEvent(eventData.element, eventData.name, eventData.listener);\n\t\t}\n\n\t\t_registeredEvents = [];\n\t};\n\n\tvar _emitEvent = function(element, name, direction) {\n\t\tif(_listeners.keyframe) {\n\t\t\t_listeners.keyframe.call(_instance, element, name, direction);\n\t\t}\n\t};\n\n\tvar _reflow = function() {\n\t\tvar pos = _instance.getScrollTop();\n\n\t\t//Will be recalculated by _updateDependentKeyFrames.\n\t\t_maxKeyFrame = 0;\n\n\t\tif(_forceHeight && !_isMobile) {\n\t\t\t//un-\"force\" the height to not mess with the calculations in _updateDependentKeyFrames (#216).\n\t\t\tbody.style.height = '';\n\t\t}\n\n\t\t_updateDependentKeyFrames();\n\n\t\tif(_forceHeight && !_isMobile) {\n\t\t\t//\"force\" the height.\n\t\t\tbody.style.height = (_maxKeyFrame + documentElement.clientHeight) + 'px';\n\t\t}\n\n\t\t//The scroll offset may now be larger than needed (on desktop the browser/os prevents scrolling farther than the bottom).\n\t\tif(_isMobile) {\n\t\t\t_instance.setScrollTop(Math.min(_instance.getScrollTop(), _maxKeyFrame));\n\t\t} else {\n\t\t\t//Remember and reset the scroll pos (#217).\n\t\t\t_instance.setScrollTop(pos, true);\n\t\t}\n\n\t\t_forceRender = true;\n\t};\n\n\t/*\n\t * Returns a copy of the constants object where all functions and strings have been evaluated.\n\t */\n\tvar _processConstants = function() {\n\t\tvar viewportHeight = documentElement.clientHeight;\n\t\tvar copy = {};\n\t\tvar prop;\n\t\tvar value;\n\n\t\tfor(prop in _constants) {\n\t\t\tvalue = _constants[prop];\n\n\t\t\tif(typeof value === 'function') {\n\t\t\t\tvalue = value.call(_instance);\n\t\t\t}\n\t\t\t//Percentage offset.\n\t\t\telse if((/p$/).test(value)) {\n\t\t\t\tvalue = (value.slice(0, -1) / 100) * viewportHeight;\n\t\t\t}\n\n\t\t\tcopy[prop] = value;\n\t\t}\n\n\t\treturn copy;\n\t};\n\n\t/*\n\t * Returns the height of the document.\n\t */\n\tvar _getDocumentHeight = function() {\n\t\tvar skrollrBodyHeight = 0;\n\t\tvar bodyHeight;\n\n\t\tif(_skrollrBody) {\n\t\t\tskrollrBodyHeight = Math.max(_skrollrBody.offsetHeight, _skrollrBody.scrollHeight);\n\t\t}\n\n\t\tbodyHeight = Math.max(skrollrBodyHeight, body.scrollHeight, body.offsetHeight, documentElement.scrollHeight, documentElement.offsetHeight, documentElement.clientHeight);\n\n\t\treturn bodyHeight - documentElement.clientHeight;\n\t};\n\n\t/**\n\t * Returns a string of space separated classnames for the current element.\n\t * Works with SVG as well.\n\t */\n\tvar _getClass = function(element) {\n\t\tvar prop = 'className';\n\n\t\t//SVG support by using className.baseVal instead of just className.\n\t\tif(window.SVGElement && element instanceof window.SVGElement) {\n\t\t\telement = element[prop];\n\t\t\tprop = 'baseVal';\n\t\t}\n\n\t\treturn element[prop];\n\t};\n\n\t/**\n\t * Adds and removes a CSS classes.\n\t * Works with SVG as well.\n\t * add and remove are arrays of strings,\n\t * or if remove is ommited add is a string and overwrites all classes.\n\t */\n\tvar _updateClass = function(element, add, remove) {\n\t\tvar prop = 'className';\n\n\t\t//SVG support by using className.baseVal instead of just className.\n\t\tif(window.SVGElement && element instanceof window.SVGElement) {\n\t\t\telement = element[prop];\n\t\t\tprop = 'baseVal';\n\t\t}\n\n\t\t//When remove is ommited, we want to overwrite/set the classes.\n\t\tif(remove === undefined) {\n\t\t\telement[prop] = add;\n\t\t\treturn;\n\t\t}\n\n\t\t//Cache current classes. We will work on a string before passing back to DOM.\n\t\tvar val = element[prop];\n\n\t\t//All classes to be removed.\n\t\tvar classRemoveIndex = 0;\n\t\tvar removeLength = remove.length;\n\n\t\tfor(; classRemoveIndex < removeLength; classRemoveIndex++) {\n\t\t\tval = _untrim(val).replace(_untrim(remove[classRemoveIndex]), ' ');\n\t\t}\n\n\t\tval = _trim(val);\n\n\t\t//All classes to be added.\n\t\tvar classAddIndex = 0;\n\t\tvar addLength = add.length;\n\n\t\tfor(; classAddIndex < addLength; classAddIndex++) {\n\t\t\t//Only add if el not already has class.\n\t\t\tif(_untrim(val).indexOf(_untrim(add[classAddIndex])) === -1) {\n\t\t\t\tval += ' ' + add[classAddIndex];\n\t\t\t}\n\t\t}\n\n\t\telement[prop] = _trim(val);\n\t};\n\n\tvar _trim = function(a) {\n\t\treturn a.replace(rxTrim, '');\n\t};\n\n\t/**\n\t * Adds a space before and after the string.\n\t */\n\tvar _untrim = function(a) {\n\t\treturn ' ' + a + ' ';\n\t};\n\n\tvar _now = Date.now || function() {\n\t\treturn +new Date();\n\t};\n\n\tvar _keyFrameComparator = function(a, b) {\n\t\treturn a.frame - b.frame;\n\t};\n\n\t/*\n\t * Private variables.\n\t */\n\n\t//Singleton\n\tvar _instance;\n\n\t/*\n\t\tA list of all elements which should be animated associated with their the metadata.\n\t\tExmaple skrollable with two key frames animating from 100px width to 20px:\n\n\t\tskrollable = {\n\t\t\telement: <the DOM element>,\n\t\t\tstyleAttr: <style attribute of the element before skrollr>,\n\t\t\tclassAttr: <class attribute of the element before skrollr>,\n\t\t\tkeyFrames: [\n\t\t\t\t{\n\t\t\t\t\tframe: 100,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\twidth: {\n\t\t\t\t\t\t\tvalue: ['{?}px', 100],\n\t\t\t\t\t\t\teasing: <reference to easing function>\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tmode: \"absolute\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tframe: 200,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\twidth: {\n\t\t\t\t\t\t\tvalue: ['{?}px', 20],\n\t\t\t\t\t\t\teasing: <reference to easing function>\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tmode: \"absolute\"\n\t\t\t\t}\n\t\t\t]\n\t\t};\n\t*/\n\tvar _skrollables;\n\n\tvar _skrollrBody;\n\n\tvar _listeners;\n\tvar _forceHeight;\n\tvar _maxKeyFrame = 0;\n\n\tvar _scale = 1;\n\tvar _constants;\n\n\tvar _mobileDeceleration;\n\n\t//Current direction (up/down).\n\tvar _direction = 'down';\n\n\t//The last top offset value. Needed to determine direction.\n\tvar _lastTop = -1;\n\n\t//The last time we called the render method (doesn't mean we rendered!).\n\tvar _lastRenderCall = _now();\n\n\t//For detecting if it actually resized (#271).\n\tvar _lastViewportWidth = 0;\n\tvar _lastViewportHeight = 0;\n\n\tvar _requestReflow = false;\n\n\t//Will contain data about a running scrollbar animation, if any.\n\tvar _scrollAnimation;\n\n\tvar _smoothScrollingEnabled;\n\n\tvar _smoothScrollingDuration;\n\n\t//Will contain settins for smooth scrolling if enabled.\n\tvar _smoothScrolling;\n\n\t//Can be set by any operation/event to force rendering even if the scrollbar didn't move.\n\tvar _forceRender;\n\n\t//Each skrollable gets an unique ID incremented for each skrollable.\n\t//The ID is the index in the _skrollables array.\n\tvar _skrollableIdCounter = 0;\n\n\tvar _edgeStrategy;\n\n\n\t//Mobile specific vars. Will be stripped by UglifyJS when not in use.\n\tvar _isMobile = false;\n\n\t//The virtual scroll offset when using mobile scrolling.\n\tvar _mobileOffset = 0;\n\n\t//If the browser supports 3d transforms, this will be filled with 'translateZ(0)' (empty string otherwise).\n\tvar _translateZ;\n\n\t//Will contain data about registered events by skrollr.\n\tvar _registeredEvents = [];\n\n\t//Animation frame id returned by RequestAnimationFrame (or timeout when RAF is not supported).\n\tvar _animFrame;\n\n\t//Expose skrollr as either a global variable or a require.js module.\n\tif(typeof define === 'function' && define.amd) {\n\t\tdefine([], function () {\n\t\t\treturn skrollr;\n\t\t});\n\t} else if (typeof module !== 'undefined' && module.exports) {\n\t\tmodule.exports = skrollr;\n\t} else {\n\t\twindow.skrollr = skrollr;\n\t}\n\n}(window, document));\n"]}